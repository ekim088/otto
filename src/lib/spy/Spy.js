// @flow
import decorateFunction, {
	revertDecoratedFunction
} from '../utils/decorateFunction';
import decorateProperty, {
	revertDecoratedProperty
} from '../utils/decorateProperty';
import type { DecoratedFunction } from '../utils/decorateFunction';

/**
 * Custom function properties that should not be spied as they are generated by
 * function decoration.
 *
 * @ignore
 */
const reservedProps: Array<string> = [
	'calls',
	'after',
	'before',
	'callThrough',
	'fake',
	'thisArg'
];

/**
 * Maintains a list of all instantiated spies.
 *
 * @ignore
 */
const spyList = [];

/**
 * Decorates a function to be spied upon.
 *
 * @namespace Spy~decorateFunctionForSpy
 * @param {object} obj The object containing the function to spy on.
 * @param {string} functionName The name of the function to spy on.
 */
function decorateFunctionForSpy(obj: { ... }, functionName: string): void {
	/**
	 * Additional Spies deployed by this Spy to spy on custom methods
	 * attached to the original function being spied on.
	 */
	const additionalSpies: Array<Spy> = [];
	const decoratedFunction: DecoratedFunction = decorateFunction.call(
		this,
		obj,
		functionName
	);

	// spy on custom function properties that had been applied to spied function
	Object.keys(decoratedFunction)
		.filter((prop: string) => reservedProps.indexOf(prop) === -1)
		.forEach((prop: string) =>
			additionalSpies.push(new Spy(decoratedFunction, prop))
		);

	// initialize reset method for function spies
	this.reset = () => {
		additionalSpies.forEach((spy: Spy): void => spy.reset());
		revertDecoratedFunction(decoratedFunction);
		this.active = false;
	};
}

/**
 * Decorates a property's getter/setter to be spied upon.
 *
 * @namespace Spy~decoratePropertyForSpy
 * @param {object} obj The object containing the property to spy on.
 * @param {string} propName The name of the property to spy on.
 */
function decoratePropertyForSpy(obj: { ... }, propName: string): void {
	decorateProperty(obj, propName);

	// initialize reset method for property spies
	this.reset = () => {
		revertDecoratedProperty(obj, propName);
		this.active = false;
	};
}

/**
 * Monitors and responds to object function calls and property value updates.
 */
export default class Spy {
	// flow annotations
	active: boolean;

	after: (?mixed) => void;

	before: ?(...args: Array<any>) => void;

	callThrough: boolean;

	fake: ?(...args: Array<any>) => mixed;

	reset: () => void;

	/**
	 * @class
	 * @param {object} obj The object containing the property to spy on.
	 * @param {string} propName The name of the property to spy on.
	 */
	constructor(obj: { ... }, propName: string) {
		if (!obj || !(propName in obj)) {
			throw new TypeError('must spy on defined object property');
		}

		/**
		 * The active status of the spy.
		 *
		 * @type {boolean}
		 */
		this.active = false;

		/**
		 * Indicates whether the function call should be completed when spying
		 * on object methods.
		 *
		 * @type {boolean}
		 */
		this.callThrough = true;

		/**
		 * Removes the spy on the object property.
		 *
		 * @type {Function}
		 */
		this.reset = () => {
			this.active = false;
		};

		// initiate spying
		this.initiate(obj, propName);

		// add Spy to instantiated list
		spyList.push(this);
	}

	/**
	 * Initiates spying.
	 *
	 * @param {object} obj The object containing the property to spy on.
	 * @param {string} propName The name of the property to spy on.
	 */
	initiate(obj: { ... }, propName: string): void {
		// decorate property with either function or getter/setter decorator
		const decorator =
			typeof obj[propName] === 'function'
				? decorateFunctionForSpy
				: decoratePropertyForSpy;
		decorator.call(this, obj, propName);
		this.active = true;
	}

	/**
	 * Resets all known instantiated spies.
	 */
	static resetAllSpies(): void {
		spyList.forEach((spy: Spy) => spy.reset());
	}
}
